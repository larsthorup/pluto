<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
    <title>RequireJS API</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="requirejs-api_files/main.css">
    <link rel="icon" type="image/x-icon" href="http://requirejs.org/favicon.png">
    <!--[if IE]> <link rel="stylesheet" type="text/css" href="../ie.css" /> <![endif]-->
    <link rel="stylesheet" type="text/css" href="requirejs-api_files/highlight.css">

    <script type="text/javascript" src="requirejs-api_files/jquery.js"></script>
    <script type="text/javascript" src="requirejs-api_files/init.js"></script>
    <script src="requirejs-api_files/dojo.js"></script>
    <script type="text/javascript">
        dojo.require("dojox.highlight");
        dojo.require("dojox.highlight.languages.javascript");
        dojo.require("dojox.highlight.languages.html");
        dojo.ready(function() {
            dojo.query("pre > code")
                .forEach(function(node) {
                    if (node.innerHTML.indexOf("DOCTYPE") !== -1 || node.innerHTML.indexOf('&lt;script') !== -1) {
                        dojo.addClass(node, "html");
                    } else {
                        dojo.addClass(node, "javascript");
                    }
                })
                .forEach(dojox.highlight.init);
        });
    </script><script src="requirejs-api_files/highlight.js" charset="utf-8" type="text/javascript"></script><script src="requirejs-api_files/javascript.js" charset="utf-8" type="text/javascript"></script><script src="requirejs-api_files/html.js" charset="utf-8" type="text/javascript"></script>
<script src="requirejs-api_files/_base.js" charset="utf-8" type="text/javascript"></script><script src="requirejs-api_files/xml.js" charset="utf-8" type="text/javascript"></script></head>
<body>
<div style="display: none; min-height: 779px;" id="grid"></div>
<div style="min-height: 779px;" id="wrapper">

    <div style="min-height: 779px;" id="navBg"></div>
    <div id="nav" class="mono">
        <a class="homeImageLink" href="http://requirejs.org/"></a>
        <h1>a javascript module loader</h1>

        <ul>
            <li class="hbox">
                <a href="http://requirejs.org/">Home</a>
                <span class="spacer boxFlex"></span>
                <span class="icon home"></span>
            </li>
        </ul>

        <ul>
            <li class="hbox">
                <a class="local" href="http://requirejs.org/docs/start.html">Start</a>
                <span class="spacer boxFlex"></span>
                <span class="icon start"></span>
            </li>
            <li class="hbox">
                <a class="local" href="http://requirejs.org/docs/download.html">Download</a>
                <span class="spacer boxFlex"></span>
                <span class="icon download"></span>
            </li>
            <li class="hbox">
                <a class="local" href="http://requirejs.org/docs/api.html">API</a>
                <span class="spacer boxFlex"></span>
                <span class="icon api"></span>
            </li>
            <li class="hbox">
                <a class="local" href="http://requirejs.org/docs/optimization.html">Optimization</a>
                <span class="spacer boxFlex"></span>
                <span class="icon optimize"></span>
            </li>
        </ul>

        <ul>
            <li class="hbox">
                <a class="local" href="http://requirejs.org/docs/jquery.html">Use with jQuery</a>
                <span class="spacer boxFlex"></span>
                <span class="icon script"></span>
            </li>
            <li class="hbox">
                <a class="local" href="http://requirejs.org/docs/node.html">Use with Node</a>
                <span class="spacer boxFlex"></span>
                <span class="icon script"></span>
            </li>
            <li class="hbox">
                <a class="local" href="http://requirejs.org/docs/dojo.html">Use with Dojo</a>
                <span class="spacer boxFlex"></span>
                <span class="icon script"></span>
            </li>
            <li class="hbox">
                <a class="local" href="http://requirejs.org/docs/commonjs.html">CommonJS Notes</a>
                <span class="spacer boxFlex"></span>
                <span class="icon script"></span>
            </li>
        </ul>

        <ul>
            <li class="hbox">
                <a class="local" href="http://requirejs.org/docs/faq.html">FAQs</a>
                <span class="spacer boxFlex"></span>
                <span class="icon question"></span>
            </li>
            <li class="hbox">
                <a class="local" href="http://requirejs.org/docs/errors.html">Common Errors</a>
                <span class="spacer boxFlex"></span>
                <span class="icon question"></span>
            </li>
            <li class="hbox">
                <a class="local" href="http://requirejs.org/docs/plugins.html">Writing Plugins</a>
                <span class="spacer boxFlex"></span>
                <span class="icon api"></span>
            </li>
        </ul>

        <ul>
            <li class="hbox">
                <a class="local" href="http://requirejs.org/docs/why.html">Why Web Modules</a>
                <span class="spacer boxFlex"></span>
                <span class="icon question"></span>
            </li>
            <li class="hbox">
                <a class="local" href="http://requirejs.org/docs/whyamd.html">Why AMD</a>
                <span class="spacer boxFlex"></span>
                <span class="icon question"></span>
            </li>
            <li class="hbox">
                <a class="local" href="http://requirejs.org/docs/requirements.html">Requirements</a>
                <span class="spacer boxFlex"></span>
                <span class="icon requirement"></span>
            </li>
            <li class="hbox">
                <a class="local" href="http://requirejs.org/docs/history.html">History</a>
                <span class="spacer boxFlex"></span>
                <span class="icon history"></span>
            </li>
        </ul>

        <ul>
            <li class="hbox">
                <a href="http://groups.google.com/group/requirejs">Get Help</a>
                <span class="spacer boxFlex"></span>
                <span class="icon help"></span>
            </li>
            <li class="hbox">
                <a href="http://tagneto.blogspot.com/">Blog</a>
                <span class="spacer boxFlex"></span>
                <span class="icon blog"></span>
            </li>
            <li class="hbox">
                <a href="http://twitter.com/jrburke">Twitter</a>
                <span class="spacer boxFlex"></span>
                <span class="icon twitter"></span>
            </li>
        </ul>

        <ul>
            <li class="hbox">
                <a href="http://github.com/jrburke/requirejs">GitHub</a>
                <span class="spacer boxFlex"></span>
                <span class="icon git"></span>
            </li>
            <li class="hbox">
                <a class="local" href="http://requirejs.org/docs/contributing.html">Contributing</a>
                <span class="spacer boxFlex"></span>
                <span class="icon fork"></span>
            </li>
        </ul>


        <ul>
            <li class="version">2.1.1 Docs (<a href="https://github.com/jrburke/requirejs/wiki/Upgrading-to-RequireJS-2.1">upgrade info</a>)</li>
            <li class="version"><a class="local" href="http://requirejs.org/docs/1.0/">1.0 Doc Link</a></li>
        </ul>

    </div>

    <div style="min-height: 611px;" id="content"><div id="directory" class="section">
<h1>RequireJS API</h1>

<span class="note">This is the <a href="https://github.com/jrburke/requirejs/wiki/Upgrading-to-RequireJS-2.0">RequireJS 2.0 API</a>. If you want 1.0: <a href="http://requirejs.org/docs/1.0/">Link to 1.0</a>.</span>

<ul class="index mono">
    <li class="hbox"><a href="#usage">Usage</a><span class="spacer boxFlex"></span><span class="sect">§§ 1-1.2</span></li>
        <ul>
            <li class="hbox"><a href="#jsfiles">Load JavaScript Files</a><span class="spacer boxFlex"></span><span class="sect">§ 1.1</span></li>
            <li class="hbox"><a href="#define">Define a Module</a><span class="spacer boxFlex"></span><span class="sect">§ 1.2</span></li>
            <ul>
                <li class="hbox"><a href="#defsimple">Simple Name/Value Pairs</a><span class="spacer boxFlex"></span><span class="sect">§ 1.2.1</span></li>
                <li class="hbox"><a href="#deffunc">Definition Functions</a><span class="spacer boxFlex"></span><span class="sect">§ 1.2.2</span></li>
                <li class="hbox"><a href="#defdep">Definition Functions with Dependencies</a><span class="spacer boxFlex"></span><span class="sect">§ 1.2.3</span></li>
                <li class="hbox"><a href="#funcmodule">Define a Module as a Function</a><span class="spacer boxFlex"></span><span class="sect">§ 1.2.4</span></li>
                <li class="hbox"><a href="#cjsmodule">Define a Module with Simplified CommonJS Wrapper</a><span class="spacer boxFlex"></span><span class="sect">§ 1.2.5</span></li>
                <li class="hbox"><a href="#modulename">Define a Module with a name</a><span class="spacer boxFlex"></span><span class="sect">§ 1.2.6</span></li>
                <li class="hbox"><a href="#modulenotes">Other Module Notes</a><span class="spacer boxFlex"></span><span class="sect">§ 1.2.7</span></li>
                <li class="hbox"><a href="#circular">Circular Dependencies</a><span class="spacer boxFlex"></span><span class="sect">§ 1.2.8</span></li>
                <li class="hbox"><a href="#jsonp">Specify a JSONP Service Dependency</a><span class="spacer boxFlex"></span><span class="sect">§ 1.2.9</span></li>
                <li class="hbox"><a href="#undef">Undefining a Module</a><span class="spacer boxFlex"></span><span class="sect">§ 1.2.10</span></li>

            </ul>
        </ul>
    <li class="hbox"><a href="#mechanics">Mechanics</a><span class="spacer boxFlex"></span><span class="sect">§§ 2</span></li>
    <li class="hbox"><a href="#config">Configuration Options</a><span class="spacer boxFlex"></span><span class="sect">§§ 3</span></li>
    <li class="hbox"><a href="#advanced">Advanced Usage</a><span class="spacer boxFlex"></span><span class="sect">§§ 4-4.6</span></li>
    <ul>
        <li class="hbox"><a href="#packages">Loading Modules from Packages</a><span class="spacer boxFlex"></span><span class="sect">§ 4.1</span></li>
        <li class="hbox"><a href="#multiversion">Multiversion Support</a><span class="spacer boxFlex"></span><span class="sect">§ 4.2</span></li>
        <li class="hbox"><a href="#afterload">Loading Code After Page Load</a><span class="spacer boxFlex"></span><span class="sect">§ 4.3</span></li>
        <li class="hbox"><a href="#webworker">Web Worker Support</a><span class="spacer boxFlex"></span><span class="sect">§ 4.4</span></li>
        <li class="hbox"><a href="#rhino">Rhino Support</a><span class="spacer boxFlex"></span><span class="sect">§ 4.5</span></li>
        <li class="hbox"><a href="#errors">Handling Errors</a><span class="spacer boxFlex"></span><span class="sect">§ 4.6</span></li>
    </ul>
    <li class="hbox"><a href="#plugins">Loader Plugins</a><span class="spacer boxFlex"></span><span class="sect">§§ 5-5.4</span></li>
        <ul>
            <li class="hbox"><a href="#text">Specify a Text File Dependency</a><span class="spacer boxFlex"></span><span class="sect">§ 5.1</span></li>
            <li class="hbox"><a href="#pageload">Page Load Event Support/DOM Ready</a><span class="spacer boxFlex"></span><span class="sect">§ 5.2</span></li>
            <li class="hbox"><a href="#i18n">Define an I18N Bundle</a><span class="spacer boxFlex"></span><span class="sect">§ 5.3</span></li>
        </ul>
</ul>
</div>

<div class="section">
<h2>
<a href="#usage" name="usage">Usage</a>
<span class="sectionMark">§ 1</span>
</h2>

<h3>
<a href="#jsfiles" name="jsfiles">Load JavaScript Files</a>
<span class="sectionMark">§ 1.1</span>
</h3>

<p>RequireJS takes a different approach to script loading than 
traditional &lt;script&gt; tags. Its goal is to encourage modular code. 
While it can also run fast and optimize well, the primary goal is to 
encourage modular code. As part of that, it encourages using <strong>module IDs</strong> instead of URLs for script tags.</p>

<p>RequireJS loads all code relative to a <a href="#config-baseUrl">baseUrl</a>.
 The baseUrl is normally set to the same directory as the script used in
 a data-main attribute for the top level script to load for a page. The 
data-main attribute is a special attribute that require.js will check to
 start script loading. This example will end up with a baseUrl of <strong>scripts</strong>:</p>

<pre><code class="html"><span class="comment">&lt;!--This sets the baseUrl to the "scripts" directory, and
    loads a script that will have a module ID of 'main'--&gt;</span>
<span class="tag">&lt;<span class="keyword">script</span><span class="attribute"> data-main=<span class="value">"scripts/main.js"</span></span><span class="attribute"> src=<span class="value">"scripts/require.js"</span></span>&gt;</span><span class="tag">&lt;/<span class="keyword">script</span>&gt;</span>
</code></pre>

<p>Or, baseUrl can be set manually via the <a href="#config">RequireJS config</a>.
 If there is no explicit config and data-main is not used, then the 
default baseUrl is the directory that contains the HTML page running 
RequireJS.</p>

<p>RequireJS also assumes by default that all dependencies are scripts, 
so it does not expect to see a trailing ".js" suffix on module IDs. 
RequireJS will automatically add it when translating the module ID to a 
path. With the <a href="#config-paths">paths config</a>, you can set
up locations of a group of scripts. All of these capabilities allow you 
to use smaller strings for scripts as compared to traditional  
&lt;script&gt; tags.</p>

<p>There may be times when you do want to reference a script directly 
and not conform to the "baseUrl + paths" rules for finding it. If a 
module ID has one of the following characterstics, the ID will not be 
passed through the "baseUrl + paths" configuration, and just be treated 
like a regular URL that is relative to the document:</p>

<ul>
<li>Ends in ".js".</li>
<li>Starts with a "/".</li>
<li>Contains an URL protocol, like "http:" or "https:".</li>
</ul>

<p>In general though, it is best to use the baseUrl and "paths" config 
to set paths for module IDs. By doing so, it gives you more flexibility 
in renaming and configuring the paths to different locations for 
optimization builds.</p>

<p>Similarly, to avoid a bunch of configuration, it is best to avoid 
deep folder hierarchies for scripts, and instead either keep all the 
scripts in baseUrl, or if you want to separate your 
library/vendor-supplied code form your app code, use a directory layout 
like this:</p>

<ul>
    <li>www/
    <ul>
        <li>index.html</li>
        <li>js/
        <ul>
            <li>app/
            <ul>
                <li>sub.js</li>
            </ul>
            </li>
            <li>lib/
            <ul>
                <li>jquery.js</li>
                <li>canvas.js</li>
            </ul></li>
            <li>app.js</li>
        </ul></li>
    </ul></li>
</ul>

<p>in index.html:</p>

<pre><code class="html"><span class="tag">&lt;<span class="keyword">script</span><span class="attribute"> data-main=<span class="value">"js/app.js"</span></span><span class="attribute"> src=<span class="value">"js/require.js"</span></span>&gt;</span><span class="tag">&lt;/<span class="keyword">script</span>&gt;</span></code></pre>

<p>and in app.js:</p>

<pre><code class="javascript">requirejs.config({
    <span class="comment">//By default load any module IDs from js/lib</span>
    baseUrl: <span class="string">'js/lib'</span>,
    <span class="comment">//except, if the module ID starts with "app",</span>
    <span class="comment">//load it from the js/app directory. paths</span>
    <span class="comment">//config is relative to the baseUrl, and</span>
    <span class="comment">//never includes a ".js" extension since</span>
    <span class="comment">//the paths config could be for a directory.</span>
    paths: {
        app: <span class="string">'../app'</span>
    }
});

<span class="comment">// Start the main app logic.</span>
requirejs([<span class="string">'jquery'</span>, <span class="string">'canvas'</span>, <span class="string">'app/sub'</span>],
<span class="function"><span class="keyword">function</span>   <span class="params">($,        canvas,   sub)</span> {</span>
    <span class="comment">//jQuery, canvas and the app/sub module are all</span>
    <span class="comment">//loaded and can be used here now.</span>
});
</code></pre>

<p>Notice as part of that example, vendor libraries like jQuery did not 
have their version numbers in their file names. It is recommended to 
store that version info in a separate text file if you want to track it,
 or if you use a tool like <a href="https://github.com/volojs/volo">volo</a>,
 it will stamp the package.json with the version information but keep 
the file on disk as "jquery.js". This allows you to have the very 
minimal configuration instead of having to put an entry in the "paths" 
config for each library. For instance, configure "jquery" to be 
"jquery-1.7.2".</p>

<p>Ideally the scripts you load will be modules that are defined by calling <a href="#define">define()</a>.
 However, you may need to use some traditional/legacy "browser globals" 
scripts that do not express their dependencies via define(). For those, 
you can use the <a href="#config-shim">shim config</a>. To properly express their dependencies.</p>

<p>If you do not express the dependencies, you will likely get loading 
errors since RequireJS loads scripts asynchronously and out of order for
 speed.</p>

<h3>
<a href="#define" name="define">Define a Module</a>
<span class="sectionMark">§ 1.2</span>
</h3>

<p>A module is different from a traditional script file in that it 
defines a well-scoped object that avoids polluting the global namespace.
 It can explicitly list its dependencies and get a handle on those 
dependencies without needing to refer to global objects, but instead 
receive the dependencies as arguments to the function that defines the 
module. Modules in RequireJS are an extension of the <a href="http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth">Module Pattern</a>, with the benefit of not needing globals to refer to other modules.</p>

<p>The RequireJS syntax for modules allows them to be loaded as fast as 
possible, even out of order, but evaluated in the correct dependency 
order, and since global variables are not created, it makes it possible 
to <a href="#multiversion">load multiple versions of a module in a page</a>.</p>

<p>(If you are familiar with or are using CommonJS modules, then please also see <a href="http://requirejs.org/docs/commonjs.html">CommonJS Notes</a> for information on how the RequirejS module format maps to CommonJS modules).</p>

<p>There should only be <strong>one</strong> module definition per file on disk. The modules can be grouped into optimized bundles by the <a href="http://requirejs.org/docs/optimization.html">optimization tool</a>.</p>

<div class="subSection">
<h4>
<a href="#defsimple" name="defsimple">Simple Name/Value Pairs</a>
<span class="sectionMark">§ 1.2.1</span>
</h4>

<p>If the module does not have any dependencies, and it is just a 
collection of name/value pairs, then just pass an object literal to 
define():</p>

<pre><code class="javascript"><span class="comment">//Inside file my/shirt.js:</span>
define({
    color: <span class="string">"black"</span>,
    size: <span class="string">"unisize"</span>
});
</code></pre>
</div>

<div class="subSection">
<h4>
<a href="#deffunc" name="deffunc">Definition Functions</a>
<span class="sectionMark">§ 1.2.2</span>
</h4>

<p>If the module does not have dependencies, but needs to use a function
 to do some setup work, then define itself, pass a function to define():</p>

<pre><code class="javascript"><span class="comment">//my/shirt.js now does setup work</span>
<span class="comment">//before returning its module definition.</span>
define(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="comment">//Do setup work here</span>

    <span class="keyword">return</span> {
        color: <span class="string">"black"</span>,
        size: <span class="string">"unisize"</span>
    }
});
</code></pre>
</div>

<div href="#subSection" class="subSection">
<h4><a href="#defdep" name="defdep">Definition Functions with Dependencies</a><span class="sectionMark">§ 1.2.3</span></h4>

<p>If the module has dependencies, the first argument should be an array
 of dependency names, and the second argument should be a definition 
function. The function will be called to define the module once all 
dependencies have loaded. The function should return an object that 
defines the module. The dependencies will be passed to the definition 
function as function arguments, listed in the same order as the order in
 the dependency array:</p>

<pre><code class="javascript"><span class="comment">//my/shirt.js now has some dependencies, a cart and inventory</span>
<span class="comment">//module in the same directory as shirt.js</span>
define([<span class="string">"./cart"</span>, <span class="string">"./inventory"</span>], <span class="function"><span class="keyword">function</span><span class="params">(cart, inventory)</span> {</span>
        <span class="comment">//return an object to define the "my/shirt" module.</span>
        <span class="keyword">return</span> {
            color: <span class="string">"blue"</span>,
            size: <span class="string">"large"</span>,
            addToCart: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
                inventory.decrement(<span class="keyword">this</span>);
                cart.add(<span class="keyword">this</span>);
            }
        }
    }
);
</code></pre>

<p>In this example, a my/shirt module is created. It depends on my/cart 
and my/inventory. On disk, the files are structured like this:</p>

<ul>
<li>my/cart.js</li>
<li>my/inventory.js</li>
<li>my/shirt.js</li>
</ul>

<p>The function call above specifies two arguments, "cart" and 
"inventory". These are the modules represented by the "./cart" and 
"./inventory" module names.</p>

<p>The function is not called until the my/cart and my/inventory modules
 have been loaded, and the function receives the modules as the "cart" 
and "inventory" arguments.</p>

<p>Modules that define globals are explicitly discouraged, so that 
multiple versions of a module can exist in a page at a time (see <strong>Advanced Usage</strong>). Also, the order of the function arguments should match the order of the dependencies.</p>

<p>The return object from the function call defines the "my/shirt" 
module. By defining modules in this way, "my/shirt" does not exist as a 
global object.</p>
</div>

<div class="subSection">
<h4><a href="#funcmodule" name="funcmodule">Define a Module as a Function</a><span class="sectionMark">§ 1.2.4</span></h4>

<p>Modules do not have to return objects. Any valid return value from a 
function is allowed. Here is a module that returns a function as its 
module definition:</p>

<pre><code class="javascript"><span class="comment">//A module definition inside foo/title.js. It uses</span>
<span class="comment">//my/cart and my/inventory modules from before,</span>
<span class="comment">//but since foo/bar.js is in a different directory than</span>
<span class="comment">//the "my" modules, it uses the "my" in the module dependency</span>
<span class="comment">//name to find them. The "my" part of the name can be mapped</span>
<span class="comment">//to any directory, but by default, it is assumed to be a</span>
<span class="comment">//sibling to the "foo" directory.</span>
define([<span class="string">"my/cart"</span>, <span class="string">"my/inventory"</span>],
    <span class="function"><span class="keyword">function</span><span class="params">(cart, inventory)</span> {</span>
        <span class="comment">//return a function to define "foo/title".</span>
        <span class="comment">//It gets or sets the window title.</span>
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(title)</span> {</span>
            <span class="keyword">return</span> title ? (window.title = title) :
                   inventory.storeName + <span class="string">' '</span> + cart.name;
        }
    }
);
</code></pre>
</div>

<div class="subSection">
<h4><a href="#cjsmodule" name="cjsmodule">Define a Module with Simplified CommonJS Wrapper</a><span class="sectionMark">§ 1.2.5</span></h4>

<p>If you wish to reuse some code that was written in the traditional <a href="http://wiki.commonjs.org/wiki/Modules/1.1.1">CommonJS module format</a> it may be difficult to re-work to the array of dependencies used above, and you may prefer to have
direct alignment of dependency name to the local variable used for that dependency. You can use the <a href="http://requirejs.org/docs/commonjs.html">simplified CommonJS wrapper</a> for those cases:</p>


<pre><code class="javascript">define(<span class="function"><span class="keyword">function</span><span class="params">(require, exports, module)</span> {</span>
        <span class="keyword">var</span> a = require(<span class="string">'a'</span>),
            b = require(<span class="string">'b'</span>);

        <span class="comment">//Return the module value</span>
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
    }
);
</code></pre>

<p>This wrapper relies on Function.prototype.toString() to give a useful
 string value of the function contents. This does not work on some 
devices like the PS3 and some older Opera mobile browsers. Use the <a href="http://requirejs.org/docs/optimization.html">optimizer</a> to pull out the dependencies in the array format for use on those devices.</p>

<p>More information is available on the <a href="http://requirejs.org/docs/commonjs.html">CommonJS page</a>, and in the in the <a href="http://requirejs.org/docs/whyamd.html#sugar">"Sugar" section in the Why AMD page</a>.
</p></div>

<div class="subSection">
<h4><a href="#modulename" name="modulename">Define a Module with a Name</a><span class="sectionMark">§ 1.2.6</span></h4>

<p>You may encounter some define() calls that include a name for the module as the first argument to define():</p>

<pre><code class="javascript">    <span class="comment">//Explicitly defines the "foo/title" module:</span>
    define(<span class="string">"foo/title"</span>,
        [<span class="string">"my/cart"</span>, <span class="string">"my/inventory"</span>],
        <span class="function"><span class="keyword">function</span><span class="params">(cart, inventory)</span> {</span>
            <span class="comment">//Define foo/title object in here.</span>
       }
    );
</code></pre>

<p>These are normally generated by the <a href="http://requirejs.org/docs/optimization.html">optimization tool</a>.
 You can explicitly name modules yourself, but it makes the modules less
 portable -- if you move the file to another directory you will need to 
change the name. It is normally best to avoid coding in a name for the 
module and just let the optimization tool burn in the module names. The 
optimization tool needs to add the names so that more than one module 
can be bundled in a file, to allow for faster loading in the browser.</p>
</div>

<div class="subSection">

<h4><a href="#modulenotes" name="modulenotes">Other Module Notes</a><span class="sectionMark">§ 1.2.7</span></h4>

<p id="modulenotes-onemodule"><strong>One module per file.</strong>: 
Only one module should be defined per JavaScript file, given the nature 
of the module name-to-file-path lookup algorithm. Multiple modules will 
be grouped into optimized files by the <a href="http://requirejs.org/docs/optimization.html">optimization tool</a>, but you should only use the optimization tool to place more than one module in a file.</p>

<p id="modulenotes-relative"><strong>Relative module names inside define()</strong>:
 For require("./relative/name") calls that can happen inside a define() 
function call, be sure to ask for "require" as a dependency, so that the
 relative name is resolved correctly:</p>

<pre><code class="javascript">define([<span class="string">"require"</span>, <span class="string">"./relative/name"</span>], <span class="function"><span class="keyword">function</span><span class="params">(require)</span> {</span>
    <span class="keyword">var</span> mod = require(<span class="string">"./relative/name"</span>);
});
</code></pre>

<p>Or better yet, use the shortened syntax that is available for use with <a href="http://requirejs.org/docs/commonjs.html">translating CommonJS</a> modules:</p>

<pre><code class="javascript">define(<span class="function"><span class="keyword">function</span><span class="params">(require)</span> {</span>
    <span class="keyword">var</span> mod = require(<span class="string">"./relative/name"</span>);
});
</code></pre>

<p>This form will use Function.prototype.toString() to find the 
require() calls, and add them to the dependency array, along with 
"require", so the code will work correctly with relative paths.</p>

<p>Relative paths are really useful if you are creating a few modules 
inside a directory, so that you can share the directory with other 
people or other projects, and you want to be able to get a handle on the
 sibling modules in that directory without
having to know the directory's name.</p>

<p id="modulenotes-urls"><strong>Generate URLs relative to module</strong>:
 You may need to generate an URL that is relative to a module. To do so,
 ask for "require" as a dependency and then use require.toUrl() to 
generate the URL:</p>

<pre><code class="javascript">define([<span class="string">"require"</span>], <span class="function"><span class="keyword">function</span><span class="params">(require)</span> {</span>
    <span class="keyword">var</span> cssUrl = require.toUrl(<span class="string">"./style.css"</span>);
});
</code></pre>

<p id="modulenotes-console"><strong>Console debugging</strong>: If you 
need to work with a module you already loaded via a 
require(["module/name"], function(){}) call in the JavaScript console, 
then you can use  the require() form that just uses the string name of 
the module to fetch it:</p>

<pre><code class="javascript">require(<span class="string">"module/name"</span>).callSomeFunction()
</code></pre>

<p>Note this only works if "module/name" was previously loaded via the 
async version of require: require(["module/name"]). If using a relative 
path, like './module/name', those only work inside define</p>
</div>

<div class="subSection">
<h4><a href="#circular" name="circular">Circular Dependencies</a><span class="sectionMark">§ 1.2.8</span></h4>

<p>If you define a circular dependency (a needs b and b needs a), then 
in this case when b's module function is called, it will get an 
undefined value for a. b can fetch a later after modules have been 
defined by using the require() method (be sure to specify require as a 
dependency so the right context is used to look up a):</p>

<pre><code class="javascript"><span class="comment">//Inside b.js:</span>
define([<span class="string">"require"</span>, <span class="string">"a"</span>],
    <span class="function"><span class="keyword">function</span><span class="params">(require, a)</span> {</span>
        <span class="comment">//"a" in this case will be null if a also asked for b,</span>
        <span class="comment">//a circular dependency.</span>
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(title)</span> {</span>
            <span class="keyword">return</span> require(<span class="string">"a"</span>).doSomething();
        }
    }
);
</code></pre>

<p>Normally you should not need to use require() to fetch a module, but 
instead rely on the module being passed in to the function as an 
argument. Circular dependencies are rare, and usually a sign that you 
might want to rethink the design. However, sometimes they are needed, 
and in that case, use require() as specified above.</p>

<p>If you are familiar with CommonJS modules, you could instead use <strong>exports</strong>
 to create an empty object for the module that is available immediately 
for reference by other modules. By doing this on both sides of a 
circular dependency, you can then safely hold on to the the other 
module. This only works if each module is exporting an object for the 
module value, not a function:</p>

<pre><code class="javascript"><span class="comment">//Inside b.js:</span>
define(<span class="function"><span class="keyword">function</span><span class="params">(require, exports, module)</span> {</span>
    <span class="comment">//If "a" has used exports, then we have a real</span>
    <span class="comment">//object reference here. However, we cannot use</span>
    <span class="comment">//any of a's properties until after b returns a value.</span>
    <span class="keyword">var</span> a = require(<span class="string">"a"</span>);

    exports.foo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span> a.bar();
    };
});
</code></pre>

<p>Or, if you are using the dependency array approach, ask for the special
<a href="https://github.com/jrburke/requirejs/wiki/Differences-between-the-simplified-CommonJS-wrapper-and-standard-AMD-define#wiki-magic">'exports' dependency:</a></p>

<pre><code class="javascript"><span class="comment">//Inside b.js:</span>
define([<span class="string">'a'</span>, <span class="string">'exports'</span>], <span class="function"><span class="keyword">function</span><span class="params">(a, exports)</span> {</span>
    <span class="comment">//If "a" has used exports, then we have a real</span>
    <span class="comment">//object reference here. However, we cannot use</span>
    <span class="comment">//any of a's properties until after b returns a value.</span>

    exports.foo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span> a.bar();
    };
});
</code></pre>

</div>

<div class="subSection">
<h4><a href="#jsonp" name="jsonp">Specify a JSONP Service Dependency</a><span class="sectionMark">§ 1.2.9</span></h4>

<p><a href="http://en.wikipedia.org/wiki/JSON#JSONP">JSONP</a> is a way 
of calling some services in JavaScript. It works across domains and it 
is an established approach to calling services that just require an HTTP
 GET via a script tag.</p>

<p>To use a JSONP service in RequireJS, specify "define" as the callback
 parameter's value. This means you can get the value of a JSONP URL as 
if it was a module definition.</p>

<p>Here is an example that calls a JSONP API endpoint. In this example, 
the JSONP callback parameter is called "callback", so "callback=define" 
tells the API to wrap the JSON response in a "define()" wrapper:</p>

<pre><code class="javascript">require([<span class="string">"http://example.com/api/data.json?callback=define"</span>],
    <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> {</span>
        <span class="comment">//The dta object will be the API response for the</span>
        <span class="comment">//JSONP data call.</span>
        console.log(data);
    }
);
</code></pre>

<p>This use of JSONP should be limited to JSONP services for initial 
application setup. If the JSONP service times out, it means other 
modules you define via define() may not get executed, so the error 
handling is not robust.</p>

<p><strong>Only JSONP return values that are JSON objects are supported</strong>. A JSONP response that is an array, a string or a number will not work.</p>

<p>This functionality should not be used for long-polling JSONP 
connections -- APIs that deal with real time streaming. Those kinds of 
APIs should do more script cleanup after receiving each response, and 
RequireJS will only fetch a JSONP URL once -- subsequent uses of the 
same URL as a dependency in a require() or define() call will get a 
cached value.</p>

<p>Errors in loading a JSONP service are normally surfaced via timeouts 
for the service, since script tag loading does not give much detail into
 network problems. To detect errors, you can override 
requirejs.onError() to get errors. There is more information in the <a href="#errors">Handling Errors</a> section.</p>

</div>

<div class="subSection">
<h4><a href="#undef" name="undef">Undefining a Module</a><span class="sectionMark">§ 1.2.10</span></h4>

<p>There is a global function, <b>requirejs.undef()</b>, that allows undefining a module. It will reset the
loader's internal state to forget about the previous definition of the module.</p>

<p><b>However</b>, it will not remove the module from other modules that are already defined and got a
handle on that module as a dependency when they executed. So it is really only useful to use in
error situations when no other modules have gotten a handle on a module value, or as part of any future
module loading that may use that module. See the <a href="#errbacks">errback section</a> for an example.</p>

<p>If you want to do more sophisticated dependency graph analysis for undefining work, the semi-private
<a href="https://github.com/jrburke/requirejs/wiki/Internal-API:-onResourceLoad">onResourceLoad API</a> may be helpful.</p>

</div>

<p></p></div><p></p>

<div class="section">
<h2>
<a href="#mechanics" name="mechanics">Mechanics</a>
<span class="sectionMark">§ 2</span>
</h2>

<p>RequireJS loads each dependency as a script tag, using head.appendChild().</p>

<p>RequireJS waits for all dependencies to load, figures out the right 
order in which to call the functions that define the modules, then calls
 the module definition functions in the right order.</p>

<p>Using RequireJS in a server-side JavaScript environment that has 
synchronous loading should be as easy as redefining require.load(). The 
build system does this, the require.load method for that environment can
 be found in build/jslib/requirePatch.js.</p>

<p>In the future, this code may be pulled into the require/ directory as
 an optional module that you can load in your env to get the right load 
behavior based on the host environment.</p>
</div>

<div class="section">
<h2>
<a href="#config" name="config">Configuration Options</a>
<span class="sectionMark">§ 3</span>
</h2>

<p>When using require() in the top-level HTML page (or top-level script 
file that does not define a module), a configuration object can be 
passed as the first option:</p>

<pre><code class="html"><span class="tag">&lt;<span class="keyword">script</span><span class="attribute"> src=<span class="value">"scripts/require.js"</span></span>&gt;</span><span class="tag">&lt;/<span class="keyword">script</span>&gt;</span>
<span class="tag">&lt;<span class="keyword">script</span>&gt;</span>
  require.config({
    baseUrl: "/another/path",
    paths: {
        "some": "some/v1.0"
    },
    waitSeconds: 15
  });
  require( ["some/module", "my/module", "a.js", "b.js"],
    function(someModule,    myModule) {
        //This function will be called when all the dependencies
        //listed above are loaded. Note that this function could
        //be called before the page is loaded.
        //This callback is optional.
    }
  );
<span class="tag">&lt;/<span class="keyword">script</span>&gt;</span>
</code></pre>

<p>Also, you can define the config object as the global variable <code>require</code> <strong>before</strong> require.js is loaded, and have the values applied automatically.
This example specifies some dependencies to load as soon as require.js defines require():</p>

<pre><code class="html"><span class="tag">&lt;<span class="keyword">script</span>&gt;</span>
    var require = {
        deps: ["some/module1", "my/module2", "a.js", "b.js"],
        callback: function(module1, module2) {
            //This function will be called when all the dependencies
            //listed above in deps are loaded. Note that this
            //function could be called before the page is loaded.
            //This callback is optional.
        }
    };
<span class="tag">&lt;/<span class="keyword">script</span>&gt;</span>
<span class="tag">&lt;<span class="keyword">script</span><span class="attribute"> src=<span class="value">"scripts/require.js"</span></span>&gt;</span><span class="tag">&lt;/<span class="keyword">script</span>&gt;</span>
</code></pre>

<p><b>Note:</b> It is best to use <code>var require = {}</code> and do not use
<code>window.require = {}</code>, it will not behave correctly in IE.</p>

<p>Supported configuration options:</p>

<p id="config-baseUrl"><strong><a href="#config-baseUrl">baseUrl</a></strong>:
 the root path to use for all module lookups. So in the above example, 
"my/module"'s script tag will have a src="/another/path/my/module.js". 
baseUrl is <strong>not</strong> used when loading plain .js files, those
 strings are used as-is, so a.js and b.js will be loaded from the same 
directory as the HTML page that contains the above snippet.</p>

<p>If no baseUrl is explicitly set in the configuration, the default 
value will be the location of the HTML page that loads require.js. If a <strong>data-main</strong> attribute is used, that path will become the baseUrl.</p>

<p>The baseUrl can be a URL on a different domain as the page that will 
load require.js. RequireJS script loading works across domains. The only
 restriction is on text content loaded by text! plugins: those paths 
should be on the same domain as the page, at least during development. 
The optimization tool will inline text! plugin resources so after using 
the optimization tool, you can use resources that reference text! plugin
 resources from another domain.</p>

<p id="config-paths"><strong><a href="#config-paths">paths</a></strong>:
 path mappings for module names not found directly under baseUrl. The 
path settings are assumed to be relative to baseUrl, unless the paths 
setting starts with a "/" or has a URL protocol in it ("like http:"). In
 those cases, the path is determined relative to baseUrl. Using the 
above sample config, "some/module"'s script tag will be 
src="/another/path/some/v1.0/module.js". The path that is used for a 
module name should <strong>not</strong> include the .js extension, since
 the path mapping could be for a directory. The path mapping code will 
automatically add the .js extension when mapping the module name to a 
path.</p>

<p id="config-shim"><strong><a href="#config-shim">shim</a></strong>: 
Configure the dependencies and exports for older, traditional "browser 
globals" scripts that do not use define() to declare the dependencies 
and set a module value. Example (RequireJS 2.1.0+):</p>


<pre><code class="javascript">requirejs.config({
    shim: {
        <span class="string">'backbone'</span>: {
            <span class="comment">//These script dependencies should be loaded before loading</span>
            <span class="comment">//backbone.js</span>
            deps: [<span class="string">'underscore'</span>, <span class="string">'jquery'</span>],
            <span class="comment">//Once loaded, use the global 'Backbone' as the</span>
            <span class="comment">//module value.</span>
            exports: <span class="string">'Backbone'</span>
        },
        <span class="string">'foo'</span>: {
            deps: [<span class="string">'bar'</span>],
            exports: <span class="string">'Foo'</span>,
            init: <span class="function"><span class="keyword">function</span> <span class="params">(bar)</span> {</span>
                <span class="comment">//Using a function allows you to call noConflict for</span>
                <span class="comment">//libraries that support it, and do other cleanup.</span>
                <span class="comment">//However, plugins for those libraries may still want</span>
                <span class="comment">//a global. "this" for the function will be the global</span>
                <span class="comment">//object. The dependencies will be passed in as</span>
                <span class="comment">//function arguments. If this function returns a value,</span>
                <span class="comment">//then that value is used as the module export value</span>
                <span class="comment">//instead of the object found via the 'exports' string.</span>
                <span class="keyword">return</span> <span class="keyword">this</span>.Foo.noConflict();
            }
        }
    }
});
</code></pre>

<p>In RequireJS 2.0.*, the "exports" property in the shim config could have
    been a function instead of a string. In that case, it functioned
the same as the "init" property as shown above. The "init" pattern is used in
RequireJS 2.1.0+ so a string value for the exports can be used for
<a href="#config-enforceDefine">enforceDefine</a>, but then allow
functional work once the library is known to have loaded.</p>

<p>For "modules" that are just jQuery or Backbone plugins that do not need to export
any module value, the shim config can just be an array of dependencies:</p>

<pre><code class="javascript">requirejs.config({
    shim: {
        <span class="string">'jquery.colorize'</span>: [<span class="string">'jquery'</span>],
        <span class="string">'jquery.scroll'</span>: [<span class="string">'jquery'</span>],
        <span class="string">'backbone.layoutmanager'</span>: [<span class="string">'backbone'</span>]
    }
});
</code></pre>

<p>Note however if you want to get 404 load detection in IE so that you 
can  use paths fallbacks or errbacks, then a string exports value should
 be given so the loader can check if the scripts actually loaded:</p>

<pre><code class="javascript">requirejs.config({
    shim: {
        <span class="string">'jquery.colorize'</span>: {
            deps: [<span class="string">'jquery'</span>],
            exports: <span class="string">'jQuery.fn.colorize'</span>
        },
        <span class="string">'jquery.scroll'</span>: {
            deps: [<span class="string">'jquery'</span>],
            exports: <span class="string">'jQuery.fn.scroll'</span>
        },
        <span class="string">'backbone.layoutmanager'</span>: {
            deps: [<span class="string">'backbone'</span>]
            exports: <span class="string">'Backbone.LayoutManager'</span>
        }
    }
});
</code></pre>

<p><b>Important caveat for "shim" config:</b></p>

<ul>
    <li>Only use other "shim" modules as dependencies for shimmed scripts, or
    AMD libraries that have no dependencies and call define() after they also
    create a global (like jQuery or lodash). Otherwise, if you use an AMD
    module as a dependency for a shim config module, after a build, that
    AMD module may not be evaluated until after the shimmed code in the build
    executes, and an error will occur. The ultimate fix is to upgrade all the
    shimmed code to have optional AMD define() calls.</li>
</ul>

<p><b>Important optimizer notes for "shim" config</b>:</p>

<ul>
    <li>You should use the <a href="http://requirejs.org/docs/optimization.html#mainConfigFile">mainConfigFile build option</a>
 to specify the file where to find the shim config. Otherwise the 
optimizer will not know of the shim config. The other option is to 
duplicate the shim config in the build profile.</li>
    <li>Do not mix CDN loading with shim config in a build. Example 
scenario: you load jQuery from the CDN but use the shim config to load 
something like the stock version of Backbone that depends on jQuery. 
When you do the build, be sure to inline jQuery in the built file and do
 not load it from the CDN. Otherwise, Backbone will be inlined in the 
built file and it will execute before the CDN-loaded jQuery will load. 
This is because the shim config just delays loading of the files until 
dependencies are loaded, but does not do any auto-wrapping of define. 
After a build, the dependencies are already inlined, the shim config 
cannot delay execution of the non-define()'d code until later. 
define()'d modules do work with CDN loaded code after a build because 
they properly wrap their source in define factory function that will not
 execute until dependencies are loaded. So the lesson: shim config is a 
stop-gap measure for for non-modular code, legacy code. define()'d 
modules are better.</li>
    <li>If you are using uglifyjs to minify the code, <strong>do not</strong> set the uglify
        option <code>toplevel</code> to true, or if using the command line
        <strong>do not</strong> pass <code>-mt</code>. That option mangles
        the global names that shim uses to find exports.</li>
</ul>

<p id="config-map"><strong><a href="#config-map">map</a></strong>: For the given module prefix, instead of loading the module with the given ID, substitute a different module ID.</p>

<p>This sort of capability is really important for larger projects which may have
two sets of modules that need to use two different versions of 'foo', but they
still need to cooperate with each other.</p>

<p>This is not possible with the <a href="#multiversion">context-backed multiversion support</a>. In addition, the <a href="#config-paths">paths config</a> is only for setting up root paths for module IDs, not for mapping one module ID to another one.</p>

<p>map example:</p>

<pre><code class="javascript">requirejs.config({
    map: {
        <span class="string">'some/newmodule'</span>: {
            <span class="string">'foo'</span>: <span class="string">'foo1.2'</span>
        },
        <span class="string">'some/oldmodule'</span>: {
            <span class="string">'foo'</span>: <span class="string">'foo1.0'</span>
        }
    }
});
</code></pre>

<p>If the modules are laid out on disk like this:</p>

<ul>
    <li>foo1.0.js</li>
    <li>foo1.2.js</li>
    <li>some/
        <ul>
            <li>newmodule.js</li>
            <li>oldmodule.js</li>
        </ul>
    </li>
</ul>

<p>When 'some/newmodule' does `require('foo')` it will get the foo1.2.js file,
and when 'some/oldmodule' does `require('foo')` it will get the foo1.0.js file.</p>

<p>This feature only works well for scripts that are real AMD modules that call
define() and register as anonymous modules.</p>

<p>There is also support for a "*" map value which means "for all 
modules loaded, use this map config". If there is a more specific map 
config, that one will take precedence over the star config. Example:</p>

<pre><code class="javascript">
requirejs.config({
    map: {
        <span class="string">'*'</span>: {
            <span class="string">'foo'</span>: <span class="string">'foo1.2'</span>
        },
        <span class="string">'some/oldmodule'</span>: {
            <span class="string">'foo'</span>: <span class="string">'foo1.0'</span>
        }
    }
});
</code></pre>

<p>Means that for any module except "some/oldmodule", when "foo" is 
wanted, use "foo1.2" instead. For "some/oldmodule" only, use "foo1.0" 
when it asks for "foo".</p>

<p id="config-moduleconfig"><strong><a href="#config-moduleconfig">config</a></strong>:
 There is a common need to pass configuration info to a module.  That 
configuration info is usually known as part of the application, and 
there needs to be a way to pass that down to a module. In RequireJS, 
that is done with the <b>config</b> option for requirejs.config(). Modules can then read that info by asking for the special dependency "module" and calling <b>module.config()</b>. Example:</p>

<pre><code class="javascript">requirejs.config({
    config: {
        <span class="string">'bar'</span>: {
            size: <span class="string">'large'</span>
        },
        <span class="string">'baz'</span>: {
            color: <span class="string">'blue'</span>
        }
    }
});

<span class="comment">//bar.js, which uses simplified CJS wrapping:</span>
<span class="comment">//http://requirejs.org/docs/whyamd.html#sugar</span>
define(<span class="function"><span class="keyword">function</span> <span class="params">(require, exports, module)</span> {</span>
    <span class="comment">//Will be the value 'large'</span>
    <span class="keyword">var</span> size = module.config().size;
});

<span class="comment">//baz.js which uses a dependency array,</span>
<span class="comment">//it asks for the special module ID, 'module':</span>
<span class="comment">//https://github.com/jrburke/requirejs/wiki/Differences-between-the-simplified-CommonJS-wrapper-and-standard-AMD-define#wiki-magic</span>
define([<span class="string">'module'</span>], <span class="function"><span class="keyword">function</span> <span class="params">(module)</span> {</span>
    <span class="comment">//Will be the value 'blue'</span>
    <span class="keyword">var</span> color = module.config().color;
});
</code></pre>

<p id="config-packages"><strong><a href="#config-packages">packages</a></strong>: configures loading modules from CommonJS packages. See the <a href="#packages">packages topic</a> for more information.</p>

<p id="config-waitSeconds"><strong><a href="#config-waitSeconds">waitSeconds</a></strong>: The number of seconds to wait before giving up on loading a script. The default is 7 seconds.</p>

<p id="config-context"><strong><a href="#config-context">context</a></strong>:
 A name to give to a loading context. This allows require.js to load 
multiple versions of modules in a page, as long as each top-level 
require call specifies a unique context string. To use it correctly, see
 the <a href="#multiversion">Multiversion Support</a> section.</p>

<p id="config-deps"><strong><a href="#config-deps">deps</a></strong>: An
 array of dependencies to load. Useful when require is defined as a 
config object before require.js is loaded, and you want to specify 
dependencies to load as soon as require() is defined.</p>

<p id="config-callback"><strong><a href="#config-callback">callback</a></strong>: A function to pass to require that should be require after <strong>deps</strong>
 have been loaded. Useful when require is defined as a config object 
before require.js is loaded, and you want to specify a function to 
require after the configuration's <strong>deps</strong> array has been loaded.</p>

<p id="config-enforceDefine"><strong><a href="#config-enforceDefine">enforceDefine</a></strong>:
 If set to true, an error will be thrown if a script loads that does not
 call define() or have a shim exports string value that can be checked. 
See <a href="#ieloadfail">Catching load failures in IE</a> for more information.</p>

<p id="config-xhtml"><strong><a href="#config-xhtml">xhtml</a></strong>: If set to true, document.createElementNS() will be used to create script elements.</p>

<p id="config-urlArgs"><strong><a href="#config-urlArgs">urlArgs</a></strong>:
 Extra query string arguments appended to URLs that RequireJS uses to 
fetch resources. Most useful to cache bust when the browser or server is
 not configured correctly. Example cache bust setting for urlArgs:</p>

<pre><code class="javascript">urlArgs: <span class="string">"bust="</span> +  (<span class="keyword">new</span> Date()).getTime()
</code></pre>

<p>During development it can be useful to use this, however <strong>be sure</strong> to remove it before deploying your code.</p>

<p id="config-scriptType"><strong><a href="#config-baseUrl">scriptType</a></strong>:
 Specify the value for the type="" attribute used for script tags 
inserted into the document by RequireJS. Default is "text/javascript". 
To use Firefox's JavaScript 1.8 features, use 
"text/javascript;version=1.8".</p>

</div>

<div class="section">
<h2>
<a href="#advanced" name="advanced">Advanced Usage</a>
<span class="sectionMark">§ 4</span>
</h2>

<h3><a href="#packages" name="packages">Loading Modules from Packages</a><span class="sectionMark">§ 4.1</span></h3>

<p>RequireJS supports loading modules that are in a <a href="http://wiki.commonjs.org/wiki/Packages/1.1">CommonJS Packages</a>
 directory structure, but some additional configuration needs to be 
specified for it to work. Specifically, there is support for the 
following CommonJS Packages features:</p>

<ul>
<li>A package can be associated with a module name/prefix.</li>
<li>The package config can specify the following properties for a specific package:
<ul>
<li><strong>name</strong>: The name of the package (used for the module name/prefix mapping)</li>
<li><strong>location</strong>: The location on disk. Locations are 
relative to the baseUrl configuration value, unless they contain a 
protocol or start with a front slash (/).</li>
<li><strong>main</strong>: The name of the module inside the package 
that should be used when someone does a require for "packageName". The 
default value is "main", so only specify it if it differs from the 
default. The value is relative to the package folder.</li>
</ul></li>
</ul>

<p><strong>IMPORTANT NOTES</strong></p>

<ul>
<li>While the packages can have the CommonJS directory layout, the 
modules themselves should be in a module format that RequireJS can 
understand. Exception to the rule: if you are using the r.js Node 
adapter, the modules can be in the traditional CommonJS module format. 
You can use the <a href="http://requirejs.org/docs/commonjs.html#autoconversion">CommonJS converter tool</a> if you need to convert traditional CommonJS modules into the async module format that RequireJS uses.</li>
<li>Only one version of a package can be used in a project context at a time. You can use RequireJS <a href="#multiversion">multiversion support</a>
 to load two different module contexts, but if you want to use Package A
 and B in one context and they depend on different versions of Package 
C, then that will be a problem. This may change in the future.</li>
</ul>

<p>If you use a similar project layout as specified in the <a href="http://requirejs.org/docs/start.html">Start Guide</a>,
 the start of your web project would look something like this 
(Node/Rhino-based projects are similar, just use the contents of the <strong>scripts</strong> directory as the top-level project directory):</p>

<ul>
<li>project-directory/
<ul>
<li>project.html</li>
<li>scripts/
<ul>
<li>require.js</li>
</ul></li>
</ul></li>
</ul>

<p>Here is how the example directory layout looks with two packages, <strong>cart</strong> and <strong>store</strong>:</p>

<ul>
<li>project-directory/
<ul>
<li>project.html</li>
<li>scripts/
<ul>
<li>omega/
<ul>
<li>main.js</li>
</ul></li>
</ul></li>
<li>cart/
<ul>
<li>main.js</li>
</ul></li>
<li>store/
<ul>
<li>main.js</li>
<li>util.js</li>
</ul></li>
<li>main.js</li>
<li>require.js</li>
</ul></li>
</ul>


<p><strong>project.html</strong> will have a script tag like this:</p>

<pre><code class="html"><span class="tag">&lt;<span class="keyword">script</span><span class="attribute"> data-main=<span class="value">"scripts/main"</span></span><span class="attribute"> src=<span class="value">"scripts/require.js"</span></span>&gt;</span><span class="tag">&lt;/<span class="keyword">script</span>&gt;</span>
</code></pre>

<p>This will instruct require.js to load scripts/main.js. <strong>main.js</strong>
 uses the "packages" config to set up packages that are relative to 
require.js, which in this case are the source packages "cart" and 
"store":</p>

<pre><code class="javascript"><span class="comment">//main.js contents</span>
<span class="comment">//Pass a config object to require</span>
require.config({
    <span class="string">"packages"</span>: [<span class="string">"cart"</span>, <span class="string">"store"</span>]
});

require([<span class="string">"cart"</span>, <span class="string">"store"</span>, <span class="string">"store/util"</span>],
<span class="function"><span class="keyword">function</span> <span class="params">(cart,   store,   util)</span> {</span>
    <span class="comment">//use the modules as usual.</span>
});
</code></pre>

<p>A require of "cart" means that it will be loaded from <strong>scripts/cart/main.js</strong>, since "main" is the default main module setting supported by RequireJS. A require of "store/util" will be loaded from <strong>scripts/store/util.js</strong>.</p>

<p>If the "store" package did not follow the "main.js" convention, and looked more like this:</p>

<ul>
<li>project-directory/
<ul>
<li>project.html</li>
<li>scripts/
<ul>
<li>cart/
<ul>
<li>main.js</li>
</ul></li>
<li>store/
<ul>
<li>store.js</li>
<li>util.js</li>
</ul></li>
<li>main.js</li>
<li>package.json</li>
<li>require.js</li>
</ul></li>
</ul></li>
</ul>

<p>Then the RequireJS configuration would look like so:</p>

<pre><code class="javascript">require.config({
    packages: [
        <span class="string">"cart"</span>,
        {
            name: <span class="string">"store"</span>,
            main: <span class="string">"store"</span>
        }
    ]
});
</code></pre>

<p>To avoid verbosity, it is strongly suggested to always use packages that use "main" convention in their structure.</p>

<h3><a href="#multiversion" name="multiversion">Multiversion Support</a><span class="sectionMark">§ 4.2</span></h3>

<p>As mentioned in <a href="#config">Configuration Options</a>, multiple
 versions of a module can be loaded in a page by using different 
"context" configuration options. require.config() returns a require 
function that will use the context configuration. Here is an example 
that loads two different versions of the alpha and beta modules (this 
example is taken from one of the test files):</p>

<pre><code class="html"><span class="tag">&lt;<span class="keyword">script</span><span class="attribute"> src=<span class="value">"../require.js"</span></span>&gt;</span><span class="tag">&lt;/<span class="keyword">script</span>&gt;</span>
<span class="tag">&lt;<span class="keyword">script</span>&gt;</span>
var reqOne = require.config({
  context: "version1",
  baseUrl: "version1"
});

reqOne(["require", "alpha", "beta",],
function(require,   alpha,   beta) {
  log("alpha version is: " + alpha.version); //prints 1
  log("beta version is: " + beta.version); //prints 1

  setTimeout(function() {
    require(["omega"],
      function(omega) {
        log("version1 omega loaded with version: " +
             omega.version); //prints 1
      }
    );
  }, 100);
});

var reqTwo = require.config({
      context: "version2",
      baseUrl: "version2"
    });

reqTwo(["require", "alpha", "beta"],
function(require,   alpha,   beta) {
  log("alpha version is: " + alpha.version); //prints 2
  log("beta version is: " + beta.version); //prints 2

  setTimeout(function() {
    require(["omega"],
      function(omega) {
        log("version2 omega loaded with version: " +
            omega.version); //prints 2
      }
    );
  }, 100);
});
<span class="tag">&lt;/<span class="keyword">script</span>&gt;</span>
</code></pre>

<p>Note that "require" is specified as a dependency for the module. This
 allows the require() function that is passed to the function callback 
to use the right context to load the modules correctly for multiversion 
support. If "require" is not specified as a dependency, then there will 
likely be an error.</p>

<h3><a href="#afterload" name="afterload">Loading Code After Page Load</a><span class="sectionMark">§ 4.3</span></h3>

<p>The example above in the <strong>Multiversion Support</strong> section shows how code can later be loaded by nested require() calls. </p>

<h3><a href="#webworker" name="webworker">Web Worker Support</a><span class="sectionMark">§ 4.4</span></h3>

<p>As of release 0.12, RequireJS can be run inside a Web Worker. Just 
use importScripts() inside a web worker to load require.js (or the JS 
file that contains the require() definition), then call require.</p>

<p>You will likely need to set the <strong>baseUrl</strong> <a href="#config">configuration option</a> to make sure require() can find the scripts to load.</p>

<p>You can see an example of its use by looking at one of the files used in <a href="http://github.com/jrburke/requirejs/blob/master/tests/workers.js">the unit test</a>.</p>

<h3><a href="#rhino" name="rhino">Rhino Support</a><span class="sectionMark">§ 4.5</span></h3>

<p>RequireJS can be used in Rhino via the <a href="http://requirejs.org/docs/download.html#rjs">r.js adapter</a>.
See <a href="https://github.com/jrburke/r.js/blob/master/README.html">the r.js README</a> for more information.</p>

<h3><a href="#errors" name="errors">Handling Errors</a><span class="sectionMark">§ 4.6</span></h3>

<p>The general class of errors are 404s for scripts (not found), network
 timeouts or errors in the scripts that are loaded. RequireJS has a few 
tools to deal with them: require-specific errbacks, a "paths" array 
config, and a global requirejs.onError.</p>

<p>The error object passed to errbacks and the global requirejs.onError function will usually contain two custom properties:</p>

<ul>
<li><strong>requireType</strong>: A string value with a general classification, like "timeout", "nodefine", "scripterror".</li>
<li><strong>requireModules</strong>: an array of module names/URLs that timed out.</li>
</ul>

<p>If you get an error with a requireModules, it probably means other 
modules that depend on the modules in that requireModules array are not 
defined.</p>

<h4>
<a href="#ieloadfail" name="ieloadfail">Catching load failures in IE</a>
<span class="sectionMark">§ 4.6.1</span>
</h4>

<p>Internet Explorer has a set of problems that make it difficult to detect load failures for errbacks/paths fallbacks:</p>

<ul>
    <li>script.onerror does not work in IE 6-8. There is no way to know 
if loading a script generates a 404, worse, it triggers the 
onreadystatechange with a complete state even in a 404 case.</li>
    <li>script.onerror does work in IE 9+, but it has a bug where it 
does not fire script.onload event handlers right after execution of 
script, so it cannot support the standard method of allowing anonymous 
AMD modules. So script.onreadystatechange is still used. However, 
onreadystatechange fires with a complete state before the script.onerror
 function fires.</li>
</ul>

<p>So it is very difficult with IE to allow both anonymous AMD modules, 
which are a core benefit of AMD modules, and reliable detect errors.</p>

<p>However, if you are in a project that you know uses define() to declare all of its modules, or it uses the <a href="#config-shim">shim</a> config to specify string exports for anything that does not use define(), then if you set the <a href="#config-enforceDefine">enforceDefine</a>
 config value to true, the loader can confirm if a script load by 
checking for the define() call or the existence of the shim's exports 
global value.</p>

<p>So if you want to support Internet Explorer, catch load errors, and 
have modular code either through direct define() calls or shim config, 
always set <b>enforceDefine</b> to be true. See the next section for an example.</p>

<p><b>NOTE</b>: If you do set enforceDefine: true, and you use data-main="" to load your main JS module, then that main JS module <b>must call define()</b>
 instead of require() to load the code it needs. The main JS module can 
still call require/requirejs to set config values, but for loading 
modules it should use define().</p>

<p>If you then also use <a href="https://github.com/jrburke/almond">almond</a> to build your code without require.js, be sure to use the <a href="https://github.com/jrburke/r.js/blob/master/build/example.build.js#L289">insertRequire</a>
 build setting to insert a require call for the main module -- that 
serves the same purpose of the initial require() call that data-main 
does.</p>

<h4>
<a href="#errbacks" name="errbacks">require([]) errbacks</a>
<span class="sectionMark">§ 4.6.2</span>
</h4>

<p>Errbacks, when used with <a href="#undef">requirejs.undef()</a>, will allow you to detect if a module fails to load, undefine
that module, reset the config to a another location, then try again.</p>

<p>A common use case for this is to use a CDN-hosted version of a library, but if
that fails, switch to loading the file locally:</p>

<pre><code class="javascript">requirejs.config({
    enforceDefine: <span class="literal">true</span>,
    paths: {
        jquery: <span class="string">'http://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min'</span>
    }
});

<span class="comment">//Later</span>
require([<span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span> <span class="params">($)</span> {</span>
    <span class="comment">//Do something with $ here</span>
}, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
    <span class="comment">//The errback, error callback</span>
    <span class="comment">//The error has a list of modules that failed</span>
    <span class="keyword">var</span> failedId = err.requireModules &amp;&amp; err.requireModules[<span class="number">0</span>],
    <span class="keyword">if</span> (failedId === <span class="string">'jquery'</span>) {
        <span class="comment">//undef is function only on the global requirejs object.</span>
        <span class="comment">//Use it to clear internal knowledge of jQuery. Any modules</span>
        <span class="comment">//that were dependent on jQuery and in the middle of loading</span>
        <span class="comment">//will not be loaded yet, they will wait until a valid jQuery</span>
        <span class="comment">//does load.</span>
        requirejs.undef(failedId);

        <span class="comment">//Set the path to jQuery to local path</span>
        requirejs.config({
            paths: {
                jquery: <span class="string">'local/jquery'</span>
            }
        });

        <span class="comment">//Try again. Note that the above require callback</span>
        <span class="comment">//with the "Do something with $ here" comment will</span>
        <span class="comment">//be called if this new attempt to load jQuery succeeds.</span>
        require([<span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>});
    } <span class="keyword">else</span> {
        <span class="comment">//Some other error. Maybe show message to the user.</span>
    }
});
</code></pre>

<p>With `requirejs.undef()`, if you later set up a different config and try to
load the same module, the loader will still remember which modules needed
that dependency and finish loading them when the newly configured module loads.</p>

<p><b>Note</b>: errbacks only work with callback-style require calls, not define()
calls. define() is only for declaring modules.</p>

<h4>
<a href="#pathsfallbacks" name="pathsfallbacks">paths config fallbacks</a>
<span class="sectionMark">§ 4.6.3</span>
</h4>

<p>The above pattern for detecting a load failure, undef()ing a module, 
modifying paths and reloading is a common enough request that there is 
also a shorthand for it. The paths config allows array values:</p>

<pre><code class="javascript">requirejs.config({
    <span class="comment">//To get timely, correct error triggers in IE, force a define/shim exports check.</span>
    enforceDefine: <span class="literal">true</span>,
    paths: {
        jquery: [
            <span class="string">'http://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min'</span>,
            <span class="comment">//If the CDN location fails, load from this location</span>
            <span class="string">'lib/jquery'</span>
        ]
    }
});

<span class="comment">//Later</span>
require([<span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span> <span class="params">($)</span> {</span>
});
</code></pre>

<p>This above code will try the CDN location, but if that fails, fall back to the local lib/jquery.js location.</p>

<p><b>Note</b>: paths fallbacks only work for exact module ID matches. This is
different from normal paths config which can apply to any part of a module ID
prefix segment. Fallbacks are targeted more for unusual error recovery, not
a generic path search path solution, since those are inefficient in the browser.</p>

<h4>
<a href="#requirejsonerror" name="requirejsonerror">Global requirejs.onError function</a>
<span class="sectionMark">§ 4.6.4</span>
</h4>

<p>To detect errors that are not caught by local errbacks, you can override requirejs.onError():</p>

<pre><code class="javascript">requirejs.onError = <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
    console.log(err.requireType);
    <span class="keyword">if</span> (err.requireType === <span class="string">'timeout'</span>) {
        console.log(<span class="string">'modules: '</span> + err.requireModules);
    }

    <span class="keyword">throw</span> err;
};
</code></pre>

</div>

<div class="section">
<h2>
<a href="#plugins" name="plugins">Loader Plugins</a>
<span class="sectionMark">§ 5</span>
</h2>

<p>RequireJS supports <a href="http://requirejs.org/docs/plugins.html">loader plugins</a>.
 This is a way to support dependencies that are not plain JS files, but 
are still important for a script to have loaded before it can do its 
work. The RequireJS wiki has <a href="https://github.com/jrburke/requirejs/wiki/Plugins">a list of plugins</a>. This section talks about some specific plugins that are maintained alongside RequireJS:</p>

<h3><a href="#text" name="text">Specify a Text File Dependency</a><span class="sectionMark">§ 5.1</span></h3>

<p>It is nice to build HTML using regular HTML tags, instead of building
 up DOM structures in script. However, there is no good way to embed 
HTML in a JavaScript file. The best that can be done is using a string 
of HTML, but that can be hard to manage, particularly for multi-line 
HTML.</p>

<p>RequireJS has a plugin, text.js, that can help with this issue. It 
will automatically be loaded if the text! prefix is used for a 
dependency. See the
<a href="https://github.com/requirejs/text">text.js README</a> for more information.</p>

<h3><a href="#pageload" name="pageload">Page Load Event Support/DOM Ready</a><span class="sectionMark">§ 5.2</span></h3>

<p>It is possible when using RequireJS to load scripts quickly enough 
that they complete before the DOM is ready. Any work that tries to 
interact with the DOM should wait for the DOM to be ready. For modern 
browsers, this is done by waiting for the DOMContentLoaded event.</p>

<p>However, not all browsers in use support DOMContentLoaded. The 
domReady module implements a cross-browser method to determine when the 
DOM is ready. <a href="http://requirejs.org/docs/download.html#domReady">Download the module</a> and use it in your project like so:</p>

<pre><code class="javascript">require([<span class="string">'domReady'</span>], <span class="function"><span class="keyword">function</span> <span class="params">(domReady)</span> {</span>
  domReady(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="comment">//This function is called once the DOM is ready.</span>
    <span class="comment">//It will be safe to query the DOM and manipulate</span>
    <span class="comment">//DOM nodes in this function.</span>
  });
});
</code></pre>

<p>Since DOM ready is a common application need, ideally the nested functions
in the API above could be avoided. The domReady module also implements the <a href="http://requirejs.org/docs/plugins.html">Loader Plugin API</a>,
so you can use the loader plugin syntax (notice the <b>!</b> in the domReady dependency) to force the
require() callback function to wait for the DOM to be ready before executing. domReady will return
the current document when used as a loader plugin:</p>

<pre><code class="javascript">require([<span class="string">'domReady!'</span>], <span class="function"><span class="keyword">function</span> <span class="params">(doc)</span> {</span>
    <span class="comment">//This function is called once the DOM is ready,</span>
    <span class="comment">//notice the value for 'domReady!' is the current</span>
    <span class="comment">//document.</span>
  });
});
</code></pre>

<p><b>Note:</b> If the document takes a while to load (maybe it is a 
very large document, or has HTML script tags loading large JS files that
 block DOM completion until they are done), using domReady as a loader 
plugin may result in a RequireJS "timeout" error. If this a problem 
either increase the <a href="#config-waitSeconds">waitSeconds</a> configuration, or just use domReady as a module and
call domReady() inside the require() callback.</p>

<h3><a href="#i18n" name="i18n">Define an I18N Bundle</a><span class="sectionMark">§ 5.3</span></h3>

<p>Once your web app gets to a certain size and popularity, localizing 
the strings in the interface and providing other locale-specific 
information becomes more useful. However, it can be cumbersome to work 
out a scheme that scales well for supporting multiple locales.</p>

<p>RequireJS allows you to set up a basic module that has localized 
information without forcing you to provide all locale-specific 
information up front. It can be added over time, and only strings/values
 that change between locales can be defined in the locale-specific file.</p>

<p>i18n bundle support is provided by the i18n.js plugin. It is 
automatically loaded when a module or dependency specifies the i18n! 
prefix (more info below). <a href="http://requirejs.org/docs/download.html#i18n">Download the plugin</a> and put it in the same directory as your app's main JS file.</p>

<p>To define a bundle, put it in a directory called "nls" -- the i18n! 
plugin assumes a module name with "nls" in it indicates an i18n bundle. 
The "nls" marker in the name tells the i18n plugin where to expect the 
locale directories (they should be immediate children of the nls 
directory). If you wanted to provide a bundle of color names in your 
"my" set of modules, create the directory structure like so:</p>

<ul>
<li>my/nls/colors.js</li>
</ul>

<p>The contents of that file should look like so:</p>

<pre><code class="javascript"><span class="comment">//my/nls/colors.js contents:</span>
define({
    <span class="string">"root"</span>: {
        <span class="string">"red"</span>: <span class="string">"red"</span>,
        <span class="string">"blue"</span>: <span class="string">"blue"</span>,
        <span class="string">"green"</span>: <span class="string">"green"</span>
    }
});
</code></pre>

<p>An object literal with a property of "root" defines this module. That
 is all you have to do to set the stage for later localization work.</p>

<p>You can then use the above module in another module, say, in a my/lamps.js file:</p>

<pre><code class="javascript"><span class="comment">//Contents of my/lamps.js</span>
define([<span class="string">"i18n!my/nls/colors"</span>], <span class="function"><span class="keyword">function</span><span class="params">(colors)</span> {</span>
    <span class="keyword">return</span> {
        testMessage: <span class="string">"The name for red in this locale is: "</span> + colors.red
    }
});
</code></pre>

<p>The my/lamps module has one property called "testMessage" that uses colors.red to show the localized value for the color red.</p>

<p>Later, when you want to add a specific translation to a file, say for the fr-fr locale, change my/nls/colors to look like so:</p>

<pre><code class="javascript"><span class="comment">//Contents of my/nls/colors.js</span>
define({
    <span class="string">"root"</span>: {
        <span class="string">"red"</span>: <span class="string">"red"</span>,
        <span class="string">"blue"</span>: <span class="string">"blue"</span>,
        <span class="string">"green"</span>: <span class="string">"green"</span>
    },
    <span class="string">"fr-fr"</span>: <span class="literal">true</span>
});
</code></pre>

<p>Then define a file at my/nls/fr-fr/colors.js that has the following contents:</p>

<pre><code class="javascript"><span class="comment">//Contents of my/nls/fr-fr/colors.js</span>
define({
    <span class="string">"red"</span>: <span class="string">"rouge"</span>,
    <span class="string">"blue"</span>: <span class="string">"bleu"</span>,
    <span class="string">"green"</span>: <span class="string">"vert"</span>
});
</code></pre>

<p>RequireJS will use the browser's navigator.language or 
navigator.userLanguage property to determine what locale values to use 
for my/nls/colors, so your app does not have to change. If you prefer to
 set the locale, you can use the <a href="#moduleconfig">module config</a> to pass the locale to the plugin:</p>

<pre><code class="javascript">requirejs.config({
    config: {
        <span class="comment">//Set the config for the i18n</span>
        <span class="comment">//module ID</span>
        i18n: {
            locale: <span class="string">'fr-fr'</span>
        }
    }
});
</code></pre>

<p><strong>Note</strong> that RequireJS will always use a lowercase 
version of the locale, to avoid case issues, so all of the directories 
and files on disk for i18n bundles should use lowercase locales.</p>

<p>RequireJS is also smart enough to pick the right locale bundle, the 
one that most closely matches the ones provided by my/nls/colors. For 
instance, if the locale is "en-us", then the "root" bundle will be used.
 If the locale is "fr-fr-paris" then the "fr-fr" bundle will be used.</p>

<p>RequireJS also combines bundles together, so for instance, if the french bundle was defined like so (omitting a value for red):</p>

<pre><code class="javascript"><span class="comment">//Contents of my/nls/fr-fr/colors.js</span>
define({
    <span class="string">"blue"</span>: <span class="string">"bleu"</span>,
    <span class="string">"green"</span>: <span class="string">"vert"</span>
});
</code></pre>

<p>Then the value for red in "root" will be used. This works for all 
locale pieces. If all the bundles listed below were defined, then 
RequireJS will use the values in the following priority order (the one 
at the top takes the most precedence):</p>

<ul>
<li>my/nls/fr-fr-paris/colors.js</li>
<li>my/nls/fr-fr/colors.js</li>
<li>my/nls/fr/colors.js</li>
<li>my/nls/colors.js</li>
</ul>

<p>If you prefer to not include the root bundle in the top level module,
 you can define it like a normal locale bundle. In that case, the top 
level module would look like:</p>

<pre><code class="javascript"><span class="comment">//my/nls/colors.js contents:</span>
define({
    <span class="string">"root"</span>: <span class="literal">true</span>,
    <span class="string">"fr-fr"</span>: <span class="literal">true</span>,
    <span class="string">"fr-fr-paris"</span>: <span class="literal">true</span>
});
</code></pre>

<p>and the root bundle would look like:</p>

<pre><code class="javascript"><span class="comment">//Contents of my/nls/root/colors.js</span>
define({
    <span class="string">"red"</span>: <span class="string">"red"</span>,
    <span class="string">"blue"</span>: <span class="string">"blue"</span>,
    <span class="string">"green"</span>: <span class="string">"green"</span>
});
</code></pre>

</div>
    </div>
    <div id="footer" class="mono">
        <span class="line">Latest Release: <a href="http://requirejs.org/docs/download.html">2.1.1</a></span>
        <span class="line">Open source: <a href="https://github.com/jrburke/requirejs/blob/master/LICENSE">new BSD or MIT licensed</a></span>
        <span class="line">web design by <a href="http://andychung.ca/">Andy Chung</a> © 2011</span>
    </div>
</div>



</body></html>